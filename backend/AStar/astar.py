# -*- coding: utf-8 -*-
"""AStar_tests.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1KqCMcLOuNYojeKkmOixsH4qBES1qxG8q
"""

""" Contient les fonctions suivantes :
        - A*
        - Dijkstra
        - get_stats_from_AStar (co2 + temps d'attente d'un chemin du AI)
        - get_stats_from_path (co2 + temps d'attente d'un chemin général)
"""

#https://github.com/ademakdogan/Implementation-of-A-Algorithm-Visualization-via-Pyp5js-/blob/master/astar/astar.py

"""A*"""

from random import randint
import os
import sys 
import time
from time import sleep
import numpy as np

class Node:

    def __init__(self, x, y):

        self.x = x 
        self.y = y
        self.f = 0
        self.g = 0 #float('inf')
        self.h = 0
        self.neighbors = []
        self.previous = None
        self.obstacle = False
        self.co2 = 0
        self.waiting_time = 0


    def add_neighbors(self, grid, columns, rows):

        neighbor_x = self.x
        neighbor_y = self.y
    
        if neighbor_x < columns - 1:
            self.neighbors.append(grid[neighbor_x+1][neighbor_y])
        if neighbor_x > 0:
            self.neighbors.append(grid[neighbor_x-1][neighbor_y])
        if neighbor_y < rows -1:
            self.neighbors.append(grid[neighbor_x][neighbor_y +1])
        if neighbor_y > 0: 
            self.neighbors.append(grid[neighbor_x][neighbor_y-1])
        #diagonals
        """
        if neighbor_x > 0 and neighbor_y > 0:
            self.neighbors.append(grid[neighbor_x-1][neighbor_y-1])
        if neighbor_x < columns -1 and neighbor_y > 0:
            self.neighbors.append(grid[neighbor_x+1][neighbor_y-1])
        if neighbor_x > 0 and neighbor_y <rows -1:
            self.neighbors.append(grid[neighbor_x-1][neighbor_y+1])
        if neighbor_x < columns -1 and neighbor_y < rows -1:
            self.neighbors.append(grid[neighbor_x+1][neighbor_y+1]) 
            """


        
class AStar:

    def __init__(self, cols, rows, start, end):

        self.cols = cols
        self.rows = rows
        self.start = start
        self.end = end

    @staticmethod
    def clean_open_set(open_set, current_node):

        for i in range(len(open_set)):
            if open_set[i] == current_node:
                open_set.pop(i)
                break

        return open_set

    @staticmethod
    def h_score(current_node, end):

        #distance =  abs(current_node.x - end.x) + abs(current_node.y - end.y)
        distance =  np.sqrt(abs(current_node.x - end.x)**2 + abs(current_node.y - end.y)**2)
        #print(f"d : {distance}")
        return distance

    @staticmethod
    def g_score(node, ecolo): #Adapt this to the tensor values

      #Dimension du co2 : 0 (valeur de co2)
      co2 = 18.0 #centaines de g co2 par km en moyenne -- ADJUST

      #Dimension du traffic : 3 (temps de retard de traffic entre 0 et 1 : 0 pas de traffic, 1 plein de traffic)
      traffic = float(ecolo[3][node.x][node.y])

      #Dimension de la vitesse : 1 (vitesse (30, 50 70, 100))
      vitesse = float(ecolo[1][node.x][node.y]) * (1-traffic) 
            
      #Dimension lumière/stop : 2 (1 : arrêt, 2 : feu de circulation)
      lum_stop = ecolo[2][node.x][node.y]

      #tps moyen à un arrêt (10 secondes)
      if lum_stop == 1: 
          lum_stop = 0.1
      #feu de circulation
      #tps moyen à un feu de circulation est 75 secondes
      elif lum_stop == 2: 
          lum_stop = 0.75 

      g = co2 * lum_stop + co2 * 1/vitesse
      #print(g, co2, lum_stop, vitesse)

      node.co2 = g
      node.waiting_time = traffic*100 + lum_stop*100 #en secondes
      #vitesse moyenne

      #print(f"g :{g}")
      return g + 1

    @staticmethod
    def create_grid(cols, rows): #don't need this

        grid = []
        for _ in range(cols):
            grid.append([])
            for _ in range(rows):
                grid[-1].append(0)
        
        return grid

    @staticmethod
    def fill_grids(grid, cols, rows, obstacle_ratio = False, obstacle_list = False):

        for i in range(cols): 
            for j in range(rows): 
                grid[i][j] = Node(i,j)
                if obstacle_ratio == False:
                    pass
                else:
                    n = randint(0,100)
                    if n < obstacle_ratio: grid[i][j].obstacle = True
        if obstacle_list == False:
            pass
        else:
            for i in range(len(obstacle_list)): #populate the grid elements that are not streets
                grid[obstacle_list[i][0]][obstacle_list[i][1]].obstacle = True 

        return grid

    @staticmethod
    def get_neighbors(grid, cols, rows):
        for i in range(cols):
            for j in range(rows):
                grid[i][j].add_neighbors(grid, cols, rows)
        return grid
    
    @staticmethod
    def start_path(open_set, closed_set, current_node, end, ecolo):

        best_way = 0
        for i in range(len(open_set)):
            #print(open_set[i].f, open_set[best_way].f)
            #Break ties according to H (be closest to the goal)
            if open_set[i].f <= open_set[best_way].f:
                if open_set[i].f == open_set[best_way].f:
                  #print(f"h : {open_set[i].h, open_set[best_way].h}")
                  if open_set[i].h < open_set[best_way].h:
                    best_way = i
                    #print(f"new best {open_set[best_way].f}")
                    #print(open_set[best_way].x,open_set[best_way].y)
                else :
                  best_way = i
                  #print(f"new best {open_set[best_way].f}")
                  #print(open_set[best_way].x,open_set[best_way].y)

        current_node = open_set[best_way] #select lowest f value to continue
        final_path = []
        if current_node == end:
            temp = current_node
            while temp.previous:
                final_path.append(temp.previous)
                temp = temp.previous

        open_set = AStar.clean_open_set(open_set, current_node)
        closed_set.append(current_node)
        neighbors = current_node.neighbors 
        #current_node.g = AStar.g_score(current_node, ecolo)

        for neighbor in neighbors:
            if (neighbor in closed_set) or (neighbor.obstacle == True):
                continue
            else:
                #print(current_node.g, AStar.g_score(neighbor, ecolo))
                temp_g = current_node.g + AStar.g_score(neighbor, ecolo)
                #temp_g = current_node.g + 1
                control_flag = 0
                for k in range(len(open_set)):
                    if neighbor.x == open_set[k].x and neighbor.y == open_set[k].y:
                        #print(neighbor.x, neighbor.y, temp_g, open_set[k].g)
                        if temp_g < open_set[k].g:
                            open_set[k].g = temp_g
                            open_set[k].h= AStar.h_score(open_set[k], end)
                            open_set[k].f = open_set[k].g + open_set[k].h
                            open_set[k].previous = current_node
                        else:
                            pass
                        control_flag = 1
                if control_flag == 1:
                    pass
                else:
                    neighbor.g = temp_g
                    neighbor.h = AStar.h_score(neighbor, end)
                    neighbor.f = neighbor.g + neighbor.h
                    neighbor.previous = current_node
                    open_set.append(neighbor)

        return open_set, closed_set, current_node, final_path

    def run_AStar(self, obstacle_list, ecolo):

        grid = AStar.create_grid(self.cols, self.rows)
        grid = AStar.fill_grids(grid, self.cols, self.rows, obstacle_list = obstacle_list)
        grid = AStar.get_neighbors(grid, self.cols, self.rows)
        open_set  = []
        closed_set  = []
        current_node = None
        final_path  = []
        open_set.append(grid[self.start[0]][self.start[1]])
        self.end = grid[self.end[0]][self.end[1]]
        while len(open_set) > 0:
            open_set, closed_set, current_node, final_path = AStar.start_path(open_set, closed_set, current_node, self.end, ecolo)
            
            if len(final_path) > 0:
                break

        return final_path
    
#---------------------------- Utility functions -------------------------

#Get obstacle list for A*
def get_obstacle_list(map):
    obstacle_list = []
    #print(np.shape(ecolo))
    for i in range(np.shape(map)[1]):
        for j in range(np.shape(map)[2]):
            if map[0][i][j] == 0:
                obstacle_list.append([i,j])
    return obstacle_list

#Generate traffic
def generate_traffic(map,p):
    #p is the probability of there being traffic
    traffic = [[0 for i in range(19)] for j in range(22)]
    p = 0.3 #probability of traffic
    for i in range(np.shape(map)[1]):
        for j in range(np.shape(map)[2]):
            if map[0][i][j] == 1:
                s = np.random.sample()
                if s <= p:
                    t = np.random.sample()
                    traffic[i][j] = t
                else:
                    traffic[i][j] = 0
    return traffic    

#Get stats from the AStar path (they have special properties)
def get_stats_from_AStar(path, end, add_last = True):
  """
        input
            path : list des coordonnées (x,y) des noeuds visités
            end : position finale
            add_last : Ajouter manuellement la fin du trajet dans la liste finale
        output
            solution_path : liste du trajet emprunté
            co2_total : total co2 sur le trajet (g/km)
            waiting_time_total : temps d'attente total (secondes)
  """
  #Total co2, total waiting time and final path in a list
  co2_total = 0
  solution_path = []
  waiting_time_total = 0

  for p in path[::-1]: #reverse from start to end
    solution_path.append((p.x,p.y))

    co2_total += p.co2
    waiting_time_total += p.waiting_time

    #print(p.co2, p.waiting_time)
  if add_last :
    x,y = end  
    solution_path.append((x,y)) #add end state

  return co2_total, waiting_time_total, solution_path

#Get stats from any path
def get_stats_from_path(path, ecolo):
  """
    inputs
      path : list of (x,y) coordinates that show the path taken ((x,y) must match with the grid map)
      ecolo : tenseur des informations relatives à la carte
    output
      total co2 (en g/km) and waiting time (en secondes) on this path
  """
  co2_total = 0
  wait_total = 0

  for x,y in path:
    #Dimension du co2 : 0 (valeur de co2)
    co2 = 18

    #Dimension du traffic : 3 (temps de retard de traffic entre 0 et 1. 0 : pas de traffic, 1 plein de traffic)
    traffic = float(ecolo[3][x][y])

    #Dimension de la vitesse : 1 (vitesse (30, 50 70, 100))
    vitesse = float(ecolo[1][x][y]) * (1-traffic)

    #Dimension lumière/stop : 2
    lum_stop = ecolo[2][x][y]
    #Stop
    if lum_stop == 1: 
        lum_stop = 0.1
    #feu de circulation
    elif lum_stop == 2: 
        lum_stop = 0.75 

    #co2 total
    c = co2 * (lum_stop + 1/vitesse)
    #print(lum_stop, vitesse, 1/vitesse, traffic, c)

    #wait total
    w = 100*(lum_stop + traffic)

    co2_total += c
    wait_total += w
  
  return co2_total, wait_total

#-------------- Shortest path trough particular nodes ----------------------

#Get shortest cost path going throush particular nodes (hard coded way)
def path_through_specific_nodes(must_visit, obstacle_list, ecolo):
  """
    Assuming we go to the physically closest node first,
    We compute the least cost path between each must visit node
    input
      must_visit : list of nodes to go through in the path
    output 
      path : final path that goes through all must visit nodes
      total_c02 : total co2 cost of the path
      total_wait : total wait time during the path
  """
  #Order the must visit by closest to start point
  start = must_visit[0]
  end = must_visit[-1]
  distances = []

  for x,y in must_visit[1:-1] :
    distances.append(np.sqrt((x-start[0])**2 + (y-start[1])**2))
  inds = np.argsort(distances)

  tmp = must_visit[1:-1]

  must_visit = [tmp[i] for i in inds]
  must_visit.append(end)
  must_visit = [start] + must_visit

  #initialisation
  path = []
  total_co2 = 0
  total_wait = 0

  #Find smallest cost path between each must visit node
  for v,u in zip(must_visit, must_visit[1:]) :
    x,y = v
    end_x, end_y = u
    #print(x,y,end_x,end_y)
    astar = AStar(25,25,[x,y],[end_x,end_y])
    p = astar.run_AStar(obstacle_list, ecolo)
      
    c, w, s = get_stats_from_AStar(p, u, add_last = False)
    total_co2 += c
    total_wait += w
    
    #Add to final path
    for e in s:
      path.append(e)

  return total_co2, total_wait, path


# ---------------- Backup algo -------------------------------------
"""If AStar does not seem optimal, can use Dijsktra."""

#Dijsktra
        
class Dijsktra:

    def __init__(self, cols, rows, start, end):

        self.cols = cols
        self.rows = rows
        self.start = start
        self.end = end

    @staticmethod
    def clean_open_set(open_set, current_node):

        for i in range(len(open_set)):
            if open_set[i] == current_node:
                open_set.pop(i)
                break

        return open_set

    @staticmethod
    def h_score(current_node, end):

        #distance =  abs(current_node.x - end.x) + abs(current_node.y - end.y)
        distance =  np.sqrt(abs(current_node.x - end.x)**2 + abs(current_node.y - end.y)**2)
        #print(f"d : {distance}")
        return distance

    @staticmethod
    def g_score(node, ecolo): #Adapt this to the tensor values

      #Dimension du co2 : 0 (valeur de co2)
      co2 = 18 #centaines de g co2 par km en moyenne -- ADJUST

      #Dimension du traffic : 3 (temps de retard de traffic entre 0 et 1 : 0 plein de traffic, 1 pas de traffic) -- ADJUST
      traffic = ecolo[3][node.x][node.y]

      #Dimension de la vitesse : 1 (vitesse (30, 50 70, 100))
      vitesse = ecolo[1][node.x][node.y] * traffic             

      #Dimension lumière/stop : 2 (1 : arrêt, 2 : feu de circulation)
      lum_stop = ecolo[2][node.x][node.y]

      #tps moyen à un arrêt (10 secondes)
      if lum_stop == 1: 
          lum_stop == 0.1
      #feu de circulation
      #tps moyen à un feu de circulation est 75 secondes
      elif lum_stop == 2: 
          lum_stop == 0.75 

      g = co2 * (lum_stop + 1/vitesse)

      node.co2 = g
      node.waiting_time = traffic*100 + lum_stop*100 #en secondes
      #vitesse moyenne

      #print(f"g :{g}")
      return g + 1

    @staticmethod
    def create_grid(cols, rows): #don't need this

        grid = []
        for _ in range(cols):
            grid.append([])
            for _ in range(rows):
                grid[-1].append(0)
        
        return grid

    @staticmethod
    def fill_grids(grid, cols, rows, obstacle_ratio = False, obstacle_list = False):

        for i in range(cols): 
            for j in range(rows): 
                grid[i][j] = Node(i,j)
                if obstacle_ratio == False:
                    pass
                else:
                    n = randint(0,100)
                    if n < obstacle_ratio: grid[i][j].obstacle = True
        if obstacle_list == False:
            pass
        else:
            for i in range(len(obstacle_list)): #populate the grid elements that are not streets
                grid[obstacle_list[i][0]][obstacle_list[i][1]].obstacle = True 

        return grid

    @staticmethod
    def get_neighbors(grid, cols, rows):
        for i in range(cols):
            for j in range(rows):
                grid[i][j].add_neighbors(grid, cols, rows)
        return grid
    
    @staticmethod
    def start_path(open_set, closed_set, current_node, end, ecolo):

        best_way = 0
        for i in range(len(open_set)):
            
            if open_set[i].g < open_set[best_way].g:
                  best_way = i
                  

        current_node = open_set[best_way] #select lowest g value to continue
        final_path = []
        if current_node == end:
            temp = current_node
            while temp.previous:
                final_path.append(temp.previous)
                temp = temp.previous

        open_set = Dijsktra.clean_open_set(open_set, current_node)
        closed_set.append(current_node)
        neighbors = current_node.neighbors 
        #current_node.g = AStar.g_score(current_node, ecolo)

        for neighbor in neighbors:
            if (neighbor in closed_set) or (neighbor.obstacle == True):
                continue
            else:
                #print(current_node.g, AStar.g_score(neighbor, ecolo))
                temp_g = current_node.g + Dijsktra.g_score(neighbor, ecolo)
                #temp_g = current_node.g + 1
                control_flag = 0
                for k in range(len(open_set)):
                    if neighbor.x == open_set[k].x and neighbor.y == open_set[k].y:
                        #print(neighbor.x, neighbor.y, temp_g, open_set[k].g)
                        if temp_g < open_set[k].g:
                            open_set[k].g = temp_g
                            #open_set[k].h= Dijsktra.h_score(open_set[k], end)
                            #open_set[k].f = open_set[k].g + open_set[k].h
                            open_set[k].previous = current_node
                        else:
                            pass
                        control_flag = 1
                if control_flag == 1:
                    pass
                else:
                    neighbor.g = temp_g
                    #neighbor.h = Dijsktra.h_score(neighbor, end)
                    #neighbor.f = neighbor.g + neighbor.h
                    neighbor.previous = current_node
                    open_set.append(neighbor)

        return open_set, closed_set, current_node, final_path

    def run_Dijsktra(self, obstacle_list, ecolo):

        grid = Dijsktra.create_grid(self.cols, self.rows)
        grid = Dijsktra.fill_grids(grid, self.cols, self.rows, obstacle_list = obstacle_list)
        grid = Dijsktra.get_neighbors(grid, self.cols, self.rows)
        open_set  = []
        closed_set  = []
        current_node = None
        final_path  = []
        open_set.append(grid[self.start[0]][self.start[1]])
        self.end = grid[self.end[0]][self.end[1]]
        while len(open_set) > 0:
            open_set, closed_set, current_node, final_path = Dijsktra.start_path(open_set, closed_set, current_node, self.end, ecolo)
            
            if len(final_path) > 0:
                break

        return final_path





